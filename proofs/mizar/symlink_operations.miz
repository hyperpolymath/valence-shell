:: SPDX-License-Identifier: PLMP-1.0-or-later
:: Valence Shell - Symlink Operations
::
:: Abstract model of symbolic link creation and removal.
:: A symlink is represented as a file node with default permissions;
:: the target path is modeled externally.

environ

 vocabularies NUMBERS, XBOOLE_0, SUBSET_1, RELAT_1, FUNCT_1, FINSEQ_1,
              STRUCT_0, FILESYS, FILE_OPS, SYMLINKS;
 notations TARSKI, XBOOLE_0, SUBSET_1, RELAT_1, FUNCT_1, FINSEQ_1, XCMPLX_0,
           NAT_1, STRUCT_0, FILESYS, FILE_OPS;
 constructors NAT_1, FINSEQ_1, FILESYS, FILE_OPS;
 registrations XBOOLE_0, SUBSET_1, NAT_1, FINSEQ_1;
 requirements NUMERALS, SUBSET, BOOLE;

begin

:: ============================================================================
:: Symlink Operations
:: ============================================================================

definition
  let p be Path;
  let fs be Filesystem;
  pred symlink_precondition p, fs means
    not path_exists(p, fs) &
    parent_exists(p, fs) &
    is_directory(parent_path(p), fs) &
    has_write_permission(parent_path(p), fs);
end;

definition
  let p be Path;
  let fs be Filesystem;
  func symlink(p, fs) -> Filesystem equals
    fs_update(p, FSNode(# FileType, DefaultPerms #), fs);
end;

definition
  let p be Path;
  let fs be Filesystem;
  func unlink(p, fs) -> Filesystem equals
    fs_remove(p, fs);
end;

:: ============================================================================
:: Postcondition Lemmas
:: ============================================================================

theorem Th_symlink_creates_path:
  for p being Path, fs being Filesystem st
    symlink_precondition p, fs
  holds path_exists(p, symlink(p, fs))
proof
  let p be Path;
  let fs be Filesystem;
  assume A1: symlink_precondition p, fs;
  thus path_exists(p, symlink(p, fs))
    by A1, FILE_OPS:Th_fs_update_creates_path;
end;

theorem Th_unlink_removes_path:
  for p being Path, fs being Filesystem st
    path_exists(p, fs)
  holds not path_exists(p, unlink(p, fs))
proof
  let p be Path;
  let fs be Filesystem;
  assume A1: path_exists(p, fs);
  thus not path_exists(p, unlink(p, fs))
    by A1, FILE_OPS:Th_fs_remove_deletes_path;
end;

:: ============================================================================
:: Reversibility Theorem
:: ============================================================================

theorem Th_symlink_unlink_reversible:
  for p being Path, fs being Filesystem st
    symlink_precondition p, fs
  holds unlink(p, symlink(p, fs)) = fs
proof
  let p be Path;
  let fs be Filesystem;
  assume A1: symlink_precondition p, fs;
  :: unlink removes the newly created path, restoring fs
  thus unlink(p, symlink(p, fs)) = fs
    by A1, FILE_OPS:Th_delete_after_create_restores;
end;

end
