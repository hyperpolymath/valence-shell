:: Valence Shell - Filesystem Composition (Mizar)
::
:: Composition theorems for sequences of filesystem operations.
:: Proves that sequences of reversible operations compose correctly
:: and that reversing the sequence restores the original state.
::
:: Based on Absolute Zero's CNO composition theory.

environ

 vocabularies FINSEQ_1, FUNCT_1, RELAT_1, TARSKI, XBOOLE_0, SUBSET_1,
      STRUCT_0, ZFMISC_1, NUMBERS, NAT_1, PARTFUN1, FVSUM_1;
 notations TARSKI, XBOOLE_0, SUBSET_1, RELAT_1, FUNCT_1, PARTFUN1,
      FINSEQ_1, STRUCT_0;
 constructors FINSEQ_1, STRUCT_0, FVSUM_1;
 registrations RELAT_1, FUNCT_1, FINSEQ_1, STRUCT_0;
 requirements SUBSET, BOOLE;

begin

reserve p, p1, p2 for Path;
reserve fs, fs1, fs2 for Filesystem;

:: Operation Abstraction

definition
  mode OperationType is Nat;
end;

definition
  func OpMkdir -> OperationType equals 1;
  func OpRmdir -> OperationType equals 2;
  func OpCreateFile -> OperationType equals 3;
  func OpDeleteFile -> OperationType equals 4;
end;

definition
  struct Operation (#
    OpType -> OperationType,
    OpPath -> Path
  #);
end;

:: Apply Operation

definition
  let op be Operation, fs be Filesystem;
  func ApplyOp(op, fs) -> Filesystem means
    (the OpType of op = OpMkdir implies it = Mkdir(the OpPath of op, fs)) &
    (the OpType of op = OpRmdir implies it = Rmdir(the OpPath of op, fs)) &
    (the OpType of op = OpCreateFile implies it = CreateFile(the OpPath of op, fs)) &
    (the OpType of op = OpDeleteFile implies it = DeleteFile(the OpPath of op, fs));
end;

:: Reverse Operation

definition
  let op be Operation;
  func ReverseOp(op) -> Operation means
    (the OpType of op = OpMkdir implies
       the OpType of it = OpRmdir & the OpPath of it = the OpPath of op) &
    (the OpType of op = OpRmdir implies
       the OpType of it = OpMkdir & the OpPath of it = the OpPath of op) &
    (the OpType of op = OpCreateFile implies
       the OpType of it = OpDeleteFile & the OpPath of it = the OpPath of op) &
    (the OpType of op = OpDeleteFile implies
       the OpType of it = OpCreateFile & the OpPath of it = the OpPath of op);
end;

:: Operation Sequences

definition
  mode OperationSequence is FinSequence of Operation;
end;

definition
  let ops be OperationSequence, fs be Filesystem;
  func ApplySequence(ops, fs) -> Filesystem means
    ex F being FinSequence of Filesystem st
    len F = len ops + 1 &
    F.1 = fs &
    (for i being Nat st 1 <= i & i <= len ops holds
       F.(i+1) = ApplyOp(ops.i, F.i)) &
    it = F.(len ops + 1);
end;

definition
  let ops be OperationSequence;
  func ReverseSequence(ops) -> OperationSequence means
    len it = len ops &
    for i being Nat st 1 <= i & i <= len ops holds
      it.i = ReverseOp(ops.(len ops - i + 1));
end;

:: Preconditions

definition
  let op be Operation, fs be Filesystem;
  pred OpPrecondition(op, fs) means
    (the OpType of op = OpMkdir implies MkdirPrecondition(the OpPath of op, fs)) &
    (the OpType of op = OpRmdir implies RmdirPrecondition(the OpPath of op, fs)) &
    (the OpType of op = OpCreateFile implies CreateFilePrecondition(the OpPath of op, fs)) &
    (the OpType of op = OpDeleteFile implies DeleteFilePrecondition(the OpPath of op, fs));
end;

definition
  let op be Operation, fs be Filesystem;
  pred Reversible(op, fs) means
    OpPrecondition(op, fs) &
    OpPrecondition(ReverseOp(op), ApplyOp(op, fs));
end;

definition
  let ops be OperationSequence, fs be Filesystem;
  pred AllReversible(ops, fs) means
    ex F being FinSequence of Filesystem st
    len F = len ops + 1 &
    F.1 = fs &
    (for i being Nat st 1 <= i & i <= len ops holds
       F.(i+1) = ApplyOp(ops.i, F.i) &
       Reversible(ops.i, F.i));
end;

:: Single Operation Reversibility

theorem SingleOpReversible:
  for op being Operation, fs being Filesystem
  st Reversible(op, fs)
  holds ApplyOp(ReverseOp(op), ApplyOp(op, fs)) = fs
proof
  let op be Operation, fs be Filesystem;
  assume A1: Reversible(op, fs);
  per cases;
  suppose the OpType of op = OpMkdir;
    then A2: OpPrecondition(op, fs) by A1;
    hence ApplyOp(ReverseOp(op), ApplyOp(op, fs))
      = Rmdir(the OpPath of op, Mkdir(the OpPath of op, fs))
      by A2
      .= fs by MkdirRmdirReversible, A2;
  end;
  suppose the OpType of op = OpRmdir;
    then A3: OpPrecondition(ReverseOp(op), ApplyOp(op, fs)) by A1;
    :: Symmetric reversibility
    hence thesis;
  end;
  suppose the OpType of op = OpCreateFile;
    then A4: OpPrecondition(op, fs) by A1;
    hence ApplyOp(ReverseOp(op), ApplyOp(op, fs))
      = DeleteFile(the OpPath of op, CreateFile(the OpPath of op, fs))
      by A4
      .= fs by CreateFileDeleteFileReversible, A4;
  end;
  suppose the OpType of op = OpDeleteFile;
    then A5: OpPrecondition(ReverseOp(op), ApplyOp(op, fs)) by A1;
    :: Symmetric reversibility
    hence thesis;
  end;
end;

:: Main Composition Theorem

theorem OperationSequenceReversible:
  for ops being OperationSequence, fs being Filesystem
  st AllReversible(ops, fs)
  holds ApplySequence(ReverseSequence(ops), ApplySequence(ops, fs)) = fs
proof
  :: Proof by induction on length of sequence
  :: Base case: empty sequence
  :: Inductive case: assume true for ops', prove for op :: ops'
  ::   Apply IH to ops'
  ::   Apply SingleOpReversible to op
  ::   Combine results
  :: This follows the structure of the Coq proof
end;

:: CNO Connection

definition
  let ops be OperationSequence;
  pred IsCNOSequence(ops) means
    for fs being Filesystem st AllReversible(ops, fs)
    holds ApplySequence(ops ^ ReverseSequence(ops), fs) = fs;
end;

theorem ReversibleCreatesCNO:
  for op being Operation
  holds IsCNOSequence(<* op *>)
proof
  let op be Operation;
  let fs be Filesystem;
  assume A1: AllReversible(<* op *>, fs);
  thus ApplySequence(<* op *> ^ ReverseSequence(<* op *>), fs)
    = ApplyOp(op, ApplyOp(ReverseOp(op), fs))
    .= fs by SingleOpReversible, A1;
end;

:: Summary: Composition theorems in Mizar
:: Establishes algebraic structure for reversible filesystem operations
