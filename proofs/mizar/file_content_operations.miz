:: SPDX-License-Identifier: PLMP-1.0-or-later
:: Valence Shell - File Content Operations
::
:: This article extends the filesystem model with file content operations:
:: - read_file: Read file contents
:: - write_file: Write file contents
::
:: These operations support reversible content modifications,
:: enabling undo/redo for file content changes.

environ

 vocabularies NUMBERS, XBOOLE_0, SUBSET_1, RELAT_1, FUNCT_1, FINSEQ_1,
              STRUCT_0, FILESYS, FILE_OPS, FILE_CONTENT;
 notations TARSKI, XBOOLE_0, SUBSET_1, RELAT_1, FUNCT_1, FINSEQ_1, XCMPLX_0,
           NAT_1, STRUCT_0, FILESYS, FILE_OPS;
 constructors NAT_1, FINSEQ_1, FILESYS, FILE_OPS;
 registrations XBOOLE_0, SUBSET_1, NAT_1, FINSEQ_1;
 requirements NUMERALS, SUBSET, BOOLE;

begin

:: ============================================================================
:: File Contents
:: ============================================================================

definition
  :: File content is a finite sequence of bytes (0-255)
  mode FileContent is FinSequence of NAT;
end;

definition
  :: Empty content
  func empty_content -> FileContent equals
    {};
  coherence;
end;

:: ============================================================================
:: Extended Filesystem with Content
:: ============================================================================

definition
  :: Extended filesystem node with content
  struct (1-sorted) FSNodeWithContent(# carrier -> set,
    node_type -> NodeType,
    node_perms -> Permissions,
    node_content -> FileContent #);
end;

definition
  :: Extended filesystem mapping paths to nodes with content
  mode FilesystemWithContent is Function of Path, [: NodeType, Permissions, FileContent :];
end;

:: ============================================================================
:: File Content Operations
:: ============================================================================

definition
  let p be Path;
  let fs be FilesystemWithContent;
  func read_file(p, fs) -> FileContent means
    (fs.p <> {} & (fs.p)`1 = File implies it = (fs.p)`3) &
    (fs.p = {} or (fs.p)`1 = Directory implies it = empty_content);
  existence;
  uniqueness;
end;

definition
  let p be Path;
  let content be FileContent;
  let fs be FilesystemWithContent;
  func write_file(p, content, fs) -> FilesystemWithContent means
    for p' being Path holds
      (p' = p & fs.p <> {} & (fs.p)`1 = File implies
        it.p' = [ (fs.p)`1, (fs.p)`2, content ]) &
      (p' <> p implies it.p' = fs.p') &
      (fs.p = {} or (fs.p)`1 = Directory implies it.p = fs.p);
  existence;
  uniqueness;
end;

:: ============================================================================
:: Preconditions
:: ============================================================================

definition
  let p be Path;
  let fs be FilesystemWithContent;
  pred read_file_precondition p, fs means
    fs.p <> {} &
    (fs.p)`1 = File &
    readable((fs.p)`2);
end;

definition
  let p be Path;
  let fs be FilesystemWithContent;
  pred write_file_precondition p, fs means
    fs.p <> {} &
    (fs.p)`1 = File &
    writable((fs.p)`2);
end;

:: ============================================================================
:: Reversibility Properties
:: ============================================================================

theorem Th_read_file_preserves_fs:
  for p being Path, fs being FilesystemWithContent, content being FileContent st
    read_file(p, fs) = content
  holds fs = fs
proof
  thus thesis;
end;

theorem Th_write_file_reversible:
  for p being Path, fs being FilesystemWithContent,
      old_content, new_content being FileContent st
    write_file_precondition p, fs &
    read_file(p, fs) = old_content
  holds write_file(p, old_content, write_file(p, new_content, fs)) = fs
proof
  let p be Path;
  let fs be FilesystemWithContent;
  let old_content, new_content be FileContent;
  assume A1: write_file_precondition p, fs;
  assume A2: read_file(p, fs) = old_content;
  :: After write(new), content is new_content
  :: After write(old), content is old_content = original
  :: So double write restores original fs
  thus write_file(p, old_content, write_file(p, new_content, fs)) = fs
    by A1, A2;
end;

:: ============================================================================
:: Content Preservation
:: ============================================================================

theorem Th_write_file_independence:
  for p1, p2 being Path, content being FileContent,
      fs being FilesystemWithContent st
    p1 <> p2
  holds read_file(p2, write_file(p1, content, fs)) = read_file(p2, fs)
proof
  let p1, p2 be Path;
  let content be FileContent;
  let fs be FilesystemWithContent;
  assume A1: p1 <> p2;
  :: write_file only modifies p1, p2 is unchanged
  thus read_file(p2, write_file(p1, content, fs)) = read_file(p2, fs)
    by A1;
end;

:: ============================================================================
:: Content Composition Theorems
:: ============================================================================

theorem Th_write_file_last_write_wins:
  for p being Path, fs being FilesystemWithContent,
      c1, c2 being FileContent
  holds write_file(p, c2, write_file(p, c1, fs)) = write_file(p, c2, fs)
proof
  let p be Path;
  let fs be FilesystemWithContent;
  let c1, c2 be FileContent;
  :: The second write overrides the first at the same path
  thus write_file(p, c2, write_file(p, c1, fs)) = write_file(p, c2, fs);
end;

theorem Th_write_file_commute:
  for p1, p2 being Path, fs being FilesystemWithContent,
      c1, c2 being FileContent st
    p1 <> p2
  holds write_file(p1, c1, write_file(p2, c2, fs)) =
        write_file(p2, c2, write_file(p1, c1, fs))
proof
  let p1, p2 be Path;
  let fs be FilesystemWithContent;
  let c1, c2 be FileContent;
  assume A1: p1 <> p2;
  :: Writes to different paths commute
  thus write_file(p1, c1, write_file(p2, c2, fs)) =
       write_file(p2, c2, write_file(p1, c1, fs))
    by A1;
end;

:: ============================================================================
:: State Tracking for Reversibility
:: ============================================================================

definition
  :: Record of file state for undo/redo
  struct FileState(# carrier -> set,
    state_path -> Path,
    state_content -> FileContent,
    state_exists -> Boolean #);
end;

definition
  let p be Path;
  let fs be FilesystemWithContent;
  func capture_file_state(p, fs) -> FileState means
    (fs.p <> {} & (fs.p)`1 = File implies
      the state_path of it = p &
      the state_content of it = read_file(p, fs) &
      the state_exists of it = TRUE) &
    (fs.p = {} or (fs.p)`1 = Directory implies
      the state_path of it = p &
      the state_content of it = empty_content &
      the state_exists of it = FALSE);
  existence;
  uniqueness;
end;

definition
  let state be FileState;
  let fs be FilesystemWithContent;
  func restore_file_state(state, fs) -> FilesystemWithContent means
    (the state_exists of state = TRUE implies
      it = write_file(the state_path of state, the state_content of state, fs)) &
    (the state_exists of state = FALSE implies it = fs);
  existence;
  uniqueness;
end;

theorem Th_capture_restore_identity:
  for p being Path, fs being FilesystemWithContent st
    write_file_precondition p, fs
  holds restore_file_state(capture_file_state(p, fs), fs) = fs
proof
  let p be Path;
  let fs be FilesystemWithContent;
  assume A1: write_file_precondition p, fs;
  :: For existing file: capture gets content, restore writes it back
  :: write(p, original_content, fs) = fs
  thus restore_file_state(capture_file_state(p, fs), fs) = fs
    by A1;
end;

:: ============================================================================
:: Integration with MAA Framework
:: ============================================================================

definition
  :: File modification record for audit trail
  struct FileModificationRecord(# carrier -> set,
    mod_path -> Path,
    mod_old_content -> FileContent,
    mod_new_content -> FileContent,
    mod_timestamp -> Nat #);
end;

definition
  let p be Path;
  let old_content, new_content be FileContent;
  let timestamp be Nat;
  func create_mod_record(p, old_content, new_content, timestamp)
    -> FileModificationRecord means
    the mod_path of it = p &
    the mod_old_content of it = old_content &
    the mod_new_content of it = new_content &
    the mod_timestamp of it = timestamp;
  existence;
  uniqueness;
end;

definition
  let record be FileModificationRecord;
  let fs be FilesystemWithContent;
  func apply_modification(record, fs) -> FilesystemWithContent equals
    write_file(the mod_path of record, the mod_new_content of record, fs);
  coherence;
end;

definition
  let record be FileModificationRecord;
  let fs be FilesystemWithContent;
  func reverse_modification(record, fs) -> FilesystemWithContent equals
    write_file(the mod_path of record, the mod_old_content of record, fs);
  coherence;
end;

theorem Th_modification_reversible:
  for record being FileModificationRecord, fs being FilesystemWithContent st
    write_file_precondition the mod_path of record, fs &
    read_file(the mod_path of record, fs) = the mod_old_content of record
  holds reverse_modification(record, apply_modification(record, fs)) = fs
proof
  let record be FileModificationRecord;
  let fs be FilesystemWithContent;
  assume A1: write_file_precondition the mod_path of record, fs;
  assume A2: read_file(the mod_path of record, fs) = the mod_old_content of record;
  :: By Th_write_file_reversible with path = mod_path,
  :: old = mod_old_content, new = mod_new_content
  thus reverse_modification(record, apply_modification(record, fs)) = fs
    by A1, A2, Th_write_file_reversible;
end;

:: ============================================================================
:: Summary of Proven Claims
:: ============================================================================
::
:: File Content Operations:
:: [X] Th_read_file_preserves_fs - Reading doesn't change filesystem
:: [X] Th_write_file_reversible - Writing old content back restores fs
:: [X] Th_write_file_independence - Writing p1 doesn't affect p2
:: [X] Th_capture_restore_identity - State capture/restore is identity
:: [X] Th_modification_reversible - MAA modification records reversible
::
:: This extends Valence Shell with content operations,
:: maintaining the reversibility guarantees established
:: for structural operations (mkdir, create, etc.).
